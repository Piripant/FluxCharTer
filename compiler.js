// Generated by CoffeeScript 1.10.0
(function() {
  var eval_funcs, ignore, inter_funcs, math_funcs, normal_seps, scopes_exps, separators, starts,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  math_funcs = {
    "pi": "Math.PI",
    "sin": "Math.sin",
    "cos": "Math.cos",
    "tan": "Math.tan",
    "abs": "Math.abs",
    "mod": "%",
    "^": "**"
  };

  inter_funcs = {
    "input": "intprtPrompt",
    "output": "intprtAlert"
  };

  eval_funcs = {
    "=": "=="
  };

  ignore = ["=", "-", "+", "*", "/", "\'", "\"", "(", ")", "<", ">"];

  starts = ["\"", "\'"];

  scopes_exps = "(\'[\\s\\S]*?\')|(\"[\\s\\S]*?\")";

  normal_seps = "\\s|(\\*)|(\\-)|(\\+)|(\\/)|(\")|(\')|(\\=)|(\\^)|(\\()|(\\))|(\\<)|(\\>)";

  separators = new RegExp(scopes_exps + "|" + normal_seps);

  this.compile = function(text, type) {
    var exp, exps, hasInterface, i, inter_keys, j, ref, ref1, result, trans_dict, trans_keys;
    exps = text.split(separators);
    i = 0;
    while (i < exps.length) {
      if (exps[i] === void 0 || exps[i] === "") {
        exps.splice(i, 1);
      } else {
        i += 1;
      }
    }
    hasInterface = false;
    inter_keys = Object.keys(inter_funcs);
    trans_dict = Object.assign(math_funcs, inter_funcs);
    if (type === evalName) {
      trans_dict = Object.assign(trans_dict, eval_funcs);
    }
    trans_keys = Object.keys(trans_dict);
    for (i = j = 0, ref = exps.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      exp = exps[i];
      if (indexOf.call(trans_keys, exp) >= 0) {
        if (indexOf.call(inter_keys, exp) >= 0) {
          hasInterface = true;
          if (type !== interName) {
            swal("Error during compilation", "An interface function was found in this non interface box.\nChange the box's text");
            return;
          }
        }
        exps[i] = trans_dict[exp];
      } else if (indexOf.call(ignore, exp) < 0 && (ref1 = exp[0], indexOf.call(starts, ref1) < 0) && isNaN(exp)) {
        exps[i] = "vars_dict[\"" + exp + "\"]";
      }
    }
    if (type === interName && !hasInterface) {
      swal("Error during compilation", "There is no interface function in this interface box.\nChange the box's text");
    }
    result = exps.join("");
    return result;
  };

}).call(this);
